package m2o

/*
MIT License

Copyright (c) 2024

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import (
	"fmt"
	"reflect"
	"runtime"
	"strings"
	"unsafe"
)

//go:generate go run generate/loops_generator.go

type Decoder[T any] struct {
	decodeFunc func(from any, to *T) (err error)
	buildInfo  []string
}

func NewDecoder[T any](something T, options ...Option) (decoder *Decoder[T], err error) {
	builder := newBuilder(options)
	return newDecoderWithBuilder(something, builder)
}

func (decoder Decoder[T]) Decode(source any, target *T) error {
	return decoder.decodeFunc(source, target)
}

func (decoder Decoder[T]) DecodeToAny(source any, target any) error {
	return decoder.decodeFunc(source, target.(*T))
}

func (decoder Decoder[T]) Produce(source any) (*T, error) {
	var target T
	err := decoder.decodeFunc(source, &target)
	return &target, err
}

func newDecoderWithBuilder[T any](something T, builder *builder) (decoder *Decoder[T], err error) {
	defer func() {
		if e := recover(); e != nil {
			var ok bool
			if err, ok = e.(error); !ok {
				err = fmt.Errorf("%v", e)
			}
		}
	}()

	var base *T
	val := reflect.ValueOf(something)
	baseType := reflect.TypeOf(base).Elem()
	decoderFn, buildInfo := builder.buildDecoder(val, baseType, 0)

	return &Decoder[T]{
		decodeFunc: func(source any, target *T) (err error) {
			if target == nil {
				var t T
				return fmt.Errorf("argument 'to' can't be nil, it should point to correct address with allocated memory for %s", fullType(reflect.TypeOf(t)))
			}

			defer func() {
				if e := recover(); e != nil {
					err = e.(error)
				}
			}()

			decoderFn(source, unsafe.Pointer(target), false)
			return nil
		},
		buildInfo: buildInfo,
	}, nil
}

// Decodes source data and stores it within target address
// If data is of value type, it stores encoded data right starting at targetAddr
// If data is of pointer or interface type, it allocates memory for concrete pointed type, calls its decoder and stores
// pointer to it within targetAddr (depending on whether it's pointer or interface)
//
// Arguments:
//
//   - sourceData: any data to be decoded
//   - targetAddr: memory address where decoded data should be placed
//   - isOmitted:  whether sourceData is omitted in input or not. Only decoder function knows how to reset value to zero, so it has to know if nil value is not a nil, but omitted value
//
// No errors expected. Panics if source data cannot be decoded into target type
// Panic should be caught within library and regular error should be returned
type decoderFunc func(sourceData any, targetAddr unsafe.Pointer, isOmitted bool)

type debugInfo []string

type fieldDef struct {
	// u - unmarshaler function
	// obfuscated to take less space in autogenerated files
	u decoderFunc

	// n - is an export field name
	// obfuscated to take less space in autogenerated files
	n string
}

type mapStringAny = map[string]interface{}

type cacheUnit struct {
	offset        uintptr
	interfaceType reflect.Type
	concreteType  reflect.Type
}

// builder builds optimized execution plan for concrete type
// execution plan is a tree of decoder functions which call each other with nested data
// this tree is created once for a target type for decoding and use every time when decoding is needed
// builder is not a part of public contract and should not be used outside
// use NewDecoder instead
type builder struct {
	// config manages the way execution plan is built
	// config can be changed only using options list, which can be supplied to constructor newBuilder
	// see options.go
	config struct {
		// set fields to zero values when no input data
		zeroOnEmpty            bool
		copyDefaultsFromBillet bool
		squashAnonymousFields  bool
		requiredByDefault      bool
		mustUseAllSource       bool
		collectBuildInfo       bool
		tagName                string
		mapstructureTagName    string
	}
	cache          map[cacheUnit]decoderFunc
	debug          []string
	profile        *profile
	customDecoders map[reflect.Type]func(any) any
}

func newBuilder(options []Option) *builder {
	b := &builder{
		cache:          make(map[cacheUnit]decoderFunc),
		customDecoders: make(map[reflect.Type]func(any) any),
	}
	b.config.tagName = "map2object"
	b.config.mapstructureTagName = "mapstructure"

	for _, option := range options {
		option(b)
	}

	return b
}

// buildDecoder builds decoder for any supported type
//
//	Arguments:
//
//	- value: inspected value to build decoder
//	- containerType: type of variable or field which holds this value. See mote in next section
//
// Why need containerType explicitly?
// Type of value within interface is always it's content type, that's why we need to know container type explicitly,
// for example to be able to decode to variable of type any:
//
//	var billet any = someConcreteValue{}
//	decoder, err := m2o.NewDecoder(billet)
//	produced, err := decoder.Produce(sourceData) // will produce a variable of type any, containing someConcreteValue{}
//
// if we were to get type of billet by reflect.TypeOf(billet), it's Kind would return reflect.Struct, which wouldn't allow us
// to know that before encoding interface header should be created
func (b *builder) buildDecoder(value reflect.Value, containerType reflect.Type, offset uintptr) (decoder decoderFunc, debug debugInfo) {
	if !value.IsValid() {
		return b.buildToEmptyInterfaceDecoder(offset)
	}

	// to prevent recursive lookup we need to cache execution flow
	cacheKey := getCacheKey(value, containerType, offset)

	if cached, ok := b.cache[cacheKey]; ok {
		return cached, nil
	}

	b.cache[cacheKey] = func(a any, u unsafe.Pointer, isOmitted bool) {
		b.cache[cacheKey](a, u, isOmitted)
	}

	if customDecoder, ok := b.customDecoders[value.Type()]; ok {
		decoder, debug = b.buildToCustomDecoder(value, offset, customDecoder)
	} else {
		switch containerType.Kind() {
		case reflect.Pointer:
			decoder, debug = b.buildDecoderToPointer(value, offset)
		case reflect.Map:
			decoder, debug = b.buildToMapDecoder(value, offset)
		case reflect.Struct:
			decoder, debug = b.buildToStructDecoder(value, offset)
		case reflect.Interface:
			decoder, debug = b.buildDecoderToInterfaceValue(value, containerType, offset)
		case reflect.Slice:
			decoder, debug = b.buildToSliceDecoder(value, offset)
		default:
			decoder, debug = b.buildToScalarValueDecoder(value.Type(), offset)
		}
	}

	b.cache[cacheKey] = func(a any, u unsafe.Pointer, isOmitted bool) {
		decoder(a, u, isOmitted)
	}

	if !b.config.collectBuildInfo {
		debug = nil
	}

	return decoder, debug
}

func getCacheKey(value reflect.Value, containerType reflect.Type, offset uintptr) (cacheKey cacheUnit) {
	cacheKey.offset = offset

	if !value.IsValid() {
		return
	}

	valueType := reflect.TypeOf(value.Interface())

	cacheKey.concreteType = valueType
	cacheKey.interfaceType = containerType

	//if containerType.Kind() == reflect.Interface && !value.IsNil() {
	//	cacheKey.interfaceType = containerType
	//}

	return cacheKey
}

type interfaceHeader struct {
	TypeAddr, DataAddr unsafe.Pointer
}

// buildDecoderToInterfaceValue builds decoder for non-empty interface value
//
// Parameters:
//
//	value - represents interface value containing concrete value to which source data should be decoded during decoding process
//
// panics if value is nil as it's impossible to guess to which concrete type source data should be decoded
func (b *builder) buildDecoderToInterfaceValue(value reflect.Value, containerType reflect.Type, offset uintptr) (decoderFunc, debugInfo) {
	//if value.IsNil() {
	//	panic(fmt.Errorf("empty interfaces cannot be unmarshaled"))
	//}
	var underlineElementValue reflect.Value

	var isConcreteValue = value.Kind() != reflect.Interface
	if isConcreteValue {
		underlineElementValue = value
	} else {
		underlineElementValue = value.Elem()
	}

	underlineElementType := underlineElementValue.Type()
	malloc := b.getMemoryAllocator(underlineElementType, "interface header")
	elementDecoder, debugInfo := b.buildDecoder(underlineElementValue, underlineElementValue.Type(), 0)

	interfaceSetter := getInterfaceSetter(containerType, underlineElementValue)
	finalDecoder := createDecoderToInterface(malloc, elementDecoder, interfaceSetter, offset, b.config.zeroOnEmpty)
	return finalDecoder, debugInfo
}

func getInterfaceSetter(interfaceType reflect.Type, underlineElementValue reflect.Value) func(unsafe.Pointer, unsafe.Pointer) {
	//isTypedInterface := interfaceType.NumMethod() > 0
	//structHasMultipleFields := underlineElementValue.Kind() == reflect.Struct && underlineElementValue.NumField() > 1
	//if isTypedInterface || structHasMultipleFields {
	//	n := reflect.New(interfaceType)
	//	n.Elem().Set(underlineElementValue)
	//
	//	var header = *(*interfaceHeader)(unsafe.Pointer(n.Pointer()))
	//	return func(i uintptr, v uintptr) {
	//		assignToInterface(i, header.TypeAddr, v)
	//	}
	//}
	underlineElementType := underlineElementValue.Type()
	return func(i, v unsafe.Pointer) {
		if v == nil {
			assignToInterface(i, nil, nil)
		} else {
			val := reflect.NewAt(underlineElementType, v).Elem()
			reflect.NewAt(interfaceType, i).Elem().Set(val)
		}
	}
}

var approximateHeapStart uintptr

func init() {
	heapVar := new(int)
	approximateHeapStart = uintptr(unsafe.Pointer(heapVar)) * 9 / 10
}

// nil pointer or pointer to stack, which cannot be modified
// trying to modify memory on stack we can corrupt stack, so we need to use some heuristic which will work in most cases
// optimizing execution
// approximateHeapStart > elemAddr - makes assumption that pointer points to stack if it's address is less
// than address of an approximate heap start retrieved during application initialization
func needReallocate(elemAddr unsafe.Pointer) bool {
	return elemAddr == nil || approximateHeapStart > uintptr(elemAddr)
}

// createDecoderToInterface returns decoderFunc which decodes source data to interface value
//
// Parameters:
//
//   - elementMemoryAllocator: The function which allocates needed block of memory
//   - decodeChildElement: decoderFunc which decodes source data
//   - originalInterfaceTypeAddr: The address of the internal representation of the Go type.
//
// Returns:
//
//   - decoderFunc
func createDecoderToInterface(elementMemoryAllocator memoryAllocator, decodeChildElement decoderFunc, assignToInterface func(i, v unsafe.Pointer), offsetInParent uintptr, zeroOnEmpty bool) decoderFunc {
	return func(sourceData any, parentAddress unsafe.Pointer, isOmitted bool) {
		interfaceHeaderUPtr := unsafe.Pointer(uintptr(parentAddress) + offsetInParent)
		interfaceHeaderPtr := (*interfaceHeader)(interfaceHeaderUPtr)

		if isOmitted {
			if zeroOnEmpty {
				assignToInterface(interfaceHeaderUPtr, nil)
			}
			return
		}

		var elemUnsafePtr = interfaceHeaderPtr.DataAddr
		var elemPtr unsafe.Pointer

		// nil pointer or pointer to stack, which cannot be modified
		// trying to modify memory on stack we can corrupt stack, so we need to use some heuristic which will work in most cases
		// optimizing execution
		// approximateHeapStart > elemAddr - makes assumption that pointer points to stack if it's address tis less
		// than address of an approximate heap start retrieved during application initialization
		var needReallocate = needReallocate(elemUnsafePtr)
		if needReallocate {
			// allocate memory for element which will be assigned to interface
			// store *byte to ensure GC doesn't collect buffer before its pointer is assigned to interface
			//
			// elem = new(ElementType)
			elemUnsafePtr = elementMemoryAllocator()
		}

		// elem.* = decode(sourceData)
		decodeChildElement(sourceData, elemUnsafePtr, isOmitted)

		if needReallocate {
			// parent.field = newElem // assuming parent.field is of interface type
			assignToInterface(interfaceHeaderUPtr, elemUnsafePtr)
			ensureGCDoesNotCollect(elemPtr)
		}
	}
}

// assignToInterface assigns the pointer newElemAddr to addrOfInterfaceHeader, assuming it stores the header of an interface.
// This allows skipping the itable search or creation step by simply:
// 1. Copying the type from the original interface header.
// 2. Setting the interface's pointer to newElemAddr.
//
// Parameters:
//
//   - interfaceHeaderAddr: The address where the pointer to the element should be stored.
//   - originalInterfaceTypeAddr: The address of the internal representation of the Go type.
//   - concreteValueAddr: The address of the concrete value the interface should point to.
func assignToInterface(interfaceHeaderUPtr, originalInterfaceTypeAddr, concreteValueAddr unsafe.Pointer) {
	if concreteValueAddr == nil {
		originalInterfaceTypeAddr = nil
	}
	newHeaderPointer := (*interfaceHeader)(interfaceHeaderUPtr)
	newHeaderPointer.TypeAddr = originalInterfaceTypeAddr
	newHeaderPointer.DataAddr = concreteValueAddr
}

func ensureGCDoesNotCollect(b any) {
	runtime.KeepAlive(b)
}

type memoryAllocator func() unsafe.Pointer

// getMemoryAllocator creates a memory allocation function with a specified allocation size.
// The allocation function returns a pointer to a byte (instead of uintptr or unsafe.Pointer)
// to ensure that the GC does not collect the allocated buffer immediately after the allocator
// returns its result.
//
// Arguments:
//
//   - size: The size in bytes of the buffer that the allocator will return.
//   - purpose: A short string explaining the purpose of the allocated memory.
//
// Returns:
//
//   - memoryAllocator - allocation function
func (b *builder) getMemoryAllocator(t reflect.Type, purpose string) memoryAllocator {
	if b.profile != nil {
		var size = t.Size()
		return func() unsafe.Pointer {
			unsafeRef := reflect.New(t)
			unsafePtr := unsafeRef.UnsafePointer()
			unsafeAddr := unsafeRef.Interface()

			runtime.SetFinalizer(unsafeAddr, func(any) {
				b.profile.addMemoryFreed(unsafePtr, size, purpose)
			})

			b.profile.addMemoryAllocated(unsafePtr, size, purpose)

			return unsafePtr
		}
	} else {
		return func() unsafe.Pointer {
			return reflect.New(t).UnsafePointer()
		}
	}
}

func (b *builder) buildToSliceDecoder(value reflect.Value, offset uintptr) (decoderFunc, debugInfo) {
	switch value.Type().Elem().Kind() {
	case reflect.Bool:
		return sliceUnmarshaler[bool](b, value, offset)
	case reflect.Uint8:
		return sliceUnmarshaler[uint8](b, value, offset)
	case reflect.Int8:
		return sliceUnmarshaler[int8](b, value, offset)
	case reflect.Int16:
		return sliceUnmarshaler[int16](b, value, offset)
	case reflect.Int32:
		return sliceUnmarshaler[int32](b, value, offset)
	case reflect.Int64:
		return sliceUnmarshaler[int64](b, value, offset)
	case reflect.Int:
		return sliceUnmarshaler[int](b, value, offset)
	case reflect.Float32:
		return sliceUnmarshaler[float32](b, value, offset)
	case reflect.Float64:
		return sliceUnmarshaler[float64](b, value, offset)
	case reflect.String:
		return sliceUnmarshaler[string](b, value, offset)
	case reflect.Struct:
		return sliceUnmarshaler[byte](b, value, offset)
	default:
		return sliceUnmarshaler[interface{}](b, value, offset)
	}
}

func zeroSlice(addr unsafe.Pointer) {
	*(*[]int)(addr) = nil
}

func sliceUnmarshaler[T any](b *builder, value reflect.Value, sliceOffset uintptr) (decoderFunc, debugInfo) {
	var underlineValue reflect.Value
	var elemContainerType = value.Type().Elem()

	// empty slice should be a slice of concrete elements which can be produced here
	if value.Len() == 0 {
		underlineValue = reflect.New(elemContainerType).Elem()
	} else {
		underlineValue = value.Index(0)
	}

	elementUnmarshaler, debug := b.buildDecoder(underlineValue, elemContainerType, 0)
	elementSize := underlineValue.Type().Size()
	makeSlice := getSliceMaker(value.Type())
	zeroOnEmpty := b.config.zeroOnEmpty || value.Len() == 0
	return func(sourceValue any, parentAddr unsafe.Pointer, _ bool) {
		sliceAddr := unsafe.Pointer(uintptr(parentAddr) + sliceOffset)
		if sourceValue == nil {
			if zeroOnEmpty {
				zeroSlice(sliceAddr)
			}
			return
		}

		if sourceSlice, ok := sourceValue.([]T); ok {
			unmarshalTypedSlice(sourceSlice, makeSlice, sliceAddr, elementUnmarshaler, elementSize)
		} else if sourceSlice, ok := sourceValue.([]interface{}); ok {
			unmarshalTypedSlice(sourceSlice, makeSlice, sliceAddr, elementUnmarshaler, elementSize)
		} else {
			sliceValue := reflect.ValueOf(sourceValue)
			if sliceValue.Kind() != reflect.Slice {
				panic(fmt.Errorf("expected slice, got %s", sliceValue.Kind()))
			}

			sourceLen := sliceValue.Len()

			if sourceLen == 0 {
				zeroSlice(sliceAddr)
				return
			}

			sliceData := makeSlice(sliceAddr, sourceLen)

			for i := 0; i < sourceLen; i++ {
				elementAddress := unsafe.Pointer(uintptr(sliceData) + elementSize*uintptr(i))
				sliceElement := sliceValue.Index(i)
				elementUnmarshaler(sliceElement.Interface(), elementAddress, false)
			}
		}
	}, debug
}

func unmarshalTypedSlice[T any](sourceSlice []T, makeSlice func(where unsafe.Pointer, capacity int) unsafe.Pointer, sliceAddress unsafe.Pointer, elementUnmarshaler decoderFunc, elementSize uintptr) {
	sourceLen := len(sourceSlice)
	sliceData := makeSlice(sliceAddress, sourceLen)

	for i := 0; i < sourceLen; i++ {
		elementAddress := unsafe.Pointer(uintptr(sliceData) + elementSize*uintptr(i))
		elementUnmarshaler(sourceSlice[i], elementAddress, false)
	}
}

func (b *builder) buildDecoderToPointer(value reflect.Value, offset uintptr) (decoderFunc, debugInfo) {
	valueType := value.Type()
	underlineType := valueType.Elem()
	var underlineValue reflect.Value

	if value.IsNil() {
		underlineValue = reflect.New(underlineType).Elem()
	} else {
		underlineValue = value.Elem()
	}

	elemUnmarshaler, info := b.buildDecoder(underlineValue, underlineType, 0)
	malloc := b.getMemoryAllocator(underlineType, "initialize pointer")
	return createDecoderToPointer(offset, malloc, elemUnmarshaler, b.config.copyDefaultsFromBillet), info
}

func createDecoderToPointer(offset uintptr, elementMemoryAllocator memoryAllocator, elementDecoder decoderFunc, copyBillet bool) decoderFunc {
	return func(sourceValue any, addressOfTargetPointer unsafe.Pointer, isOmitted bool) {
		elemPtr := (*unsafe.Pointer)(unsafe.Pointer(uintptr(addressOfTargetPointer) + offset))
		if isOmitted {
			*elemPtr = nil
			return
		}

		needReallocate := copyBillet || needReallocate(*elemPtr)
		if needReallocate {
			*elemPtr = elementMemoryAllocator()
		}
		elementDecoder(sourceValue, *elemPtr, false)
	}
}

func (b *builder) recursiveStructure(val reflect.Value, structureOffset uintptr) ([]fieldDef, []fieldDef, []string) {
	var optionalFields, requiredFields []fieldDef
	structType := val.Type()

	var debug []string

	for i := 0; i < structType.NumField(); i++ {
		var fieldsList = &optionalFields
		if b.config.requiredByDefault {
			fieldsList = &requiredFields
		}

		structField := structType.Field(i)
		if !structField.IsExported() {
			continue
		}

		var squash = structField.Anonymous && b.config.squashAnonymousFields

		var exportName string
		var alias string

		if !squash {
			mapstructureTagName := b.config.mapstructureTagName
			if name, ok := structField.Tag.Lookup(mapstructureTagName); ok {
				split := strings.Split(name, ",")
				name := split[0]
				if name != "" {
					exportName = name
				}
				for i := 1; i < len(split); i++ {
					part := split[i]
					if part == "squash" {
						squash = true
						break
					}
					split := strings.SplitN(split[1], "=", 2)
					if len(split) == 2 {
						if split[0] == "alias" {
							alias = split[1]
						}
					}
				}
			}
		}

		if !squash {
			tagName := b.config.tagName
			if tag, ok := structField.Tag.Lookup(tagName); ok {
				split := strings.Split(tag, ",")
				if split[0] != "" {
					if exportName != "" {
						panic(fmt.Errorf("umbiguous name: %s, %s", exportName, split[0]))
					}
					exportName = split[0]
				}

				var optionalOrRequired bool
				for i := 1; i < len(split); i++ {
					switch split[i] {
					case "optional":
						if optionalOrRequired {
							panic(fmt.Errorf("tag %s contains umbiguous options: required and optional", tagName))
						}
						optionalOrRequired = true
						fieldsList = &optionalFields
					case "required":
						if optionalOrRequired {
							panic(fmt.Errorf("tag %s contains umbiguous options: required and optional", tagName))
						}
						optionalOrRequired = true
						fieldsList = &requiredFields
					}
				}
			}
		}

		// squash can be changed by tag
		if squash {
			field := val.Field(i)
			anonymousOptionalFields, anonymousRequiredFields, info := b.recursiveStructure(field, structureOffset+structField.Offset)
			debug = append(debug, info...)

			optionalFields = append(optionalFields, anonymousOptionalFields...)
			requiredFields = append(requiredFields, anonymousRequiredFields...)
			continue
		}

		if name, ok := structField.Tag.Lookup("json"); ok {
			name := strings.SplitN(name, ",", 2)[0]
			if name != "" {
				exportName = name
			}
		}

		if exportName == "" {
			exportName = structField.Name
		}

		field := val.Field(i)

		unmarshaler, info := b.buildDecoder(field, structField.Type, structureOffset+structField.Offset)
		debug = append(debug, info...)

		// if nothing to unmarshal, for example, structure with no fields
		if unmarshaler == nil {
			continue
		}

		*fieldsList = append(*fieldsList, fieldDef{
			u: unmarshaler,
			n: exportName,
		})

		if alias != "" {
			*fieldsList = append(*fieldsList, fieldDef{
				u: unmarshaler,
				n: alias,
			})
		}
	}
	return optionalFields, requiredFields, debug
}

func structHasNonZeroFields(val reflect.Value) bool {
	if val.Kind() != reflect.Struct {
		panic("shouldn't call with non structure")
	}

	// Iterate through the struct fields
	for i := 0; i < val.NumField(); i++ {
		field := val.Field(i)
		if !field.IsZero() {
			return true
		}
		//// Check if the field is valid and settable (even for unexported fields)
		//if field.CanInterface() {
		//	if !isZeroValue(field) {
		//		return true
		//	}
		//} else {
		//
		//	// Handle unexported fields using reflection
		//	if !isZeroValue(reflect.NewAt(field.Type(), unsafe.Pointer(field.UnsafeAddr())).Elem()) {
		//		return true
		//	}
		//}
	}
	return false
}

func (b *builder) buildToStructDecoder(val reflect.Value, offset uintptr) (decoderFunc, debugInfo) {
	optionalFields, requiredFields, info := b.recursiveStructure(val, offset)

	var decoders []decoderFunc

	if b.config.mustUseAllSource {
		totalFields := len(optionalFields) + len(requiredFields)
		decoders = append(decoders, notAllFieldsUsed(totalFields))
	}

	if b.config.copyDefaultsFromBillet && structHasNonZeroFields(val) {
		decoders = append(decoders, withInitializer(val))
	}

	if decoderOptional := unrolledLoopOptional(optionalFields); decoderOptional != nil {
		decoders = append(decoders, decoderOptional)
	}

	if decoderRequired := unrolledLoopRequired(requiredFields); decoderRequired != nil {
		decoders = append(decoders, decoderRequired)
	}

	decoder := composeDecoders(decoders)

	if !b.config.zeroOnEmpty {
		return func(sourceData any, targetAddr unsafe.Pointer, isOmitted bool) {
			if isOmitted {
				return
			}
			decoder(sourceData, targetAddr, isOmitted)
		}, info
	}
	return decoder, info
}

func notAllFieldsUsed(fieldsCount int) decoderFunc {
	return func(a any, u unsafe.Pointer, isOmitted bool) {
		len := reflect.ValueOf(a).Len()
		if len > fieldsCount {
			panic(fmt.Errorf("object supports %d fields. Got for decoding: %d", fieldsCount, len))
		}
	}
}

func composeDecoders(decoders []decoderFunc) decoderFunc {
	switch len(decoders) {
	case 0:
		return nil
	case 1:
		return decoders[0]
	case 2:
		return func(a any, u unsafe.Pointer, isOmitted bool) {
			decoders[0](a, u, isOmitted)
			decoders[1](a, u, isOmitted)
		}
	case 3:
		return func(a any, u unsafe.Pointer, isOmitted bool) {
			decoders[0](a, u, isOmitted)
			decoders[1](a, u, isOmitted)
			decoders[2](a, u, isOmitted)
		}
	case 4:
		return func(a any, u unsafe.Pointer, isOmitted bool) {
			decoders[0](a, u, isOmitted)
			decoders[1](a, u, isOmitted)
			decoders[2](a, u, isOmitted)
			decoders[3](a, u, isOmitted)
		}
	default:
		panic("not implemented")
	}
}

func withInitializer(value reflect.Value) decoderFunc {
	size := value.Type().Size()
	addressable := reflect.New(value.Type())
	addressable.Elem().Set(value)
	var srcPtr = (*byte)(addressable.UnsafePointer())
	tmp := unsafe.Slice(srcPtr, size)
	c := make([]byte, size)
	copy(c, tmp)

	return func(a any, u unsafe.Pointer, isOmitted bool) {
		var uPtr = (*byte)(u)
		p := unsafe.Slice(uPtr, size)
		copy(p, c)
		// all pointers from value should be alive
		ensureGCDoesNotCollect(value)
	}
}

func (b *builder) buildToScalarValueDecoder(t reflect.Type, offset uintptr) (decoderFunc, debugInfo) {
	switch t.Kind() {
	case reflect.Bool:
		return toScalarDecoder[bool](b, offset)
	case reflect.Int:
		return toScalarDecoder[int](b, offset)
	case reflect.Int8:
		return toScalarDecoder[int8](b, offset)
	case reflect.Uint8:
		return toScalarDecoder[uint8](b, offset)
	case reflect.Int16:
		return toScalarDecoder[int16](b, offset)
	case reflect.Uint16:
		return toScalarDecoder[uint16](b, offset)
	case reflect.Int32:
		return toScalarDecoder[int32](b, offset)
	case reflect.Uint32:
		return toScalarDecoder[uint32](b, offset)
	case reflect.Int64:
		return toScalarDecoder[int64](b, offset)
	case reflect.Uint64:
		return toScalarDecoder[uint64](b, offset)
	case reflect.Float32:
		return toScalarDecoder[float32](b, offset)
	case reflect.Float64:
		return toScalarDecoder[float64](b, offset)
	case reflect.Complex64:
		return toScalarDecoder[complex64](b, offset)
	case reflect.Complex128:
		return toScalarDecoder[complex128](b, offset)
	case reflect.String:
		return toScalarDecoder[string](b, offset)
	default:
		panic(fmt.Errorf("Simple unmarshaler cannot unmarshal this kind: %s", t.Kind().String()))
	}
}

func (b *builder) buildToCustomDecoder(value reflect.Value, offset uintptr, decoder func(any) any) (decoderFunc, debugInfo) {
	targetType := value.Type()
	return func(a any, u unsafe.Pointer, isOmitted bool) {
		result := decoder(a)
		resultValue := reflect.ValueOf(result)
		resultType := resultValue.Type()
		if resultType != targetType {
			gotType := fullType(resultType)
			neededType := fullType(targetType)
			panic(fmt.Errorf("custom decoder returned incorrect type: %s instead of %s", gotType, neededType))
		}

		reflect.NewAt(targetType, unsafe.Pointer(uintptr(u)+offset)).Elem().Set(resultValue)
	}, []string{"used custom decoder"}
}

func (b *builder) buildToEmptyInterfaceDecoder(offset uintptr) (decoderFunc, debugInfo) {
	return func(a any, u unsafe.Pointer, isOmitted bool) {
		*(*any)(unsafe.Pointer(uintptr(u) + offset)) = a
	}, nil
}

func fullType(t reflect.Type) (result string) {
	if t.PkgPath() != "" {
		result = t.PkgPath() + "/"
	}
	result += t.Name()

	if result == "" {
		return t.String()
	}
	return
}

func toScalarDecoder[T any](b *builder, offset uintptr) (decoderFunc, debugInfo) {
	var t T
	targetType := reflect.TypeOf(t)
	zeroOnEmpty := b.config.zeroOnEmpty
	return func(value any, addr unsafe.Pointer, isOmitted bool) {
		var typedValue T
		if isOmitted {
			if !zeroOnEmpty {
				return
			}
			// leave zero value untouched
		} else {
			var ok bool
			// basic scalar type
			if typedValue, ok = value.(T); !ok {
				valueType := reflect.TypeOf(value)
				if !valueType.ConvertibleTo(targetType) {
					// in case of panic it will be caught at root and regular error will be returned
					panic(fmt.Errorf("error converting, source cannot be converted to target: got %s, expected %s", valueType, targetType))
				}
				// it's a some kind of derivation
				converted := reflect.ValueOf(value).Convert(targetType)
				targetValue := reflect.NewAt(targetType, unsafe.Pointer(uintptr(addr)+offset)).Elem()
				targetValue.Set(converted)
				return
			}
		}

		// Treat add + offset as pointer to memory where value should be placed
		ptr := (*T)(unsafe.Pointer(uintptr(addr) + offset))
		*ptr = typedValue
	}, nil
}
